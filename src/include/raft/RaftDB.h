// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.7.
// **********************************************************************

#ifndef __RAFTDB_H_
#define __RAFTDB_H_

#include <map>
#include <string>
#include <vector>
#include "client/protocol/Tars.h"
using namespace std;
#include "client/ServantProxy.h"
#include "client/Servant.h"


namespace horsedb
{
    enum EStatus
    {
        E_OK = 0,
        E_Timeout = 1,
        E_NoSuchKey = 2,
        E_NotLeader = 3,
        E_Default = 4,
    };
    inline string etos(const EStatus & e)
    {
        switch(e)
        {
            case E_OK: return "E_OK";
            case E_Timeout: return "E_Timeout";
            case E_NoSuchKey: return "E_NoSuchKey";
            case E_NotLeader: return "E_NotLeader";
            case E_Default: return "E_Default";
            default: return "";
        }
    }
    inline int stoe(const string & s, EStatus & e)
    {
        if(s == "E_OK")  { e=E_OK; return 0;}
        if(s == "E_Timeout")  { e=E_Timeout; return 0;}
        if(s == "E_NoSuchKey")  { e=E_NoSuchKey; return 0;}
        if(s == "E_NotLeader")  { e=E_NotLeader; return 0;}
        if(s == "E_Default")  { e=E_Default; return 0;}

        return -1;
    }

    enum CommandType
    {
        CM_Noop = 0,
        CM_Get = 1,
        CM_Put = 2,
        CM_Del = 3,
        CM_Config = 4,
    };
    inline string etos(const CommandType & e)
    {
        switch(e)
        {
            case CM_Noop: return "CM_Noop";
            case CM_Get: return "CM_Get";
            case CM_Put: return "CM_Put";
            case CM_Del: return "CM_Del";
            case CM_Config: return "CM_Config";
            default: return "";
        }
    }
    inline int stoe(const string & s, CommandType & e)
    {
        if(s == "CM_Noop")  { e=CM_Noop; return 0;}
        if(s == "CM_Get")  { e=CM_Get; return 0;}
        if(s == "CM_Put")  { e=CM_Put; return 0;}
        if(s == "CM_Del")  { e=CM_Del; return 0;}
        if(s == "CM_Config")  { e=CM_Config; return 0;}

        return -1;
    }

    struct VoteInfoMeta : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.VoteInfoMeta";
        }
        static string MD5()
        {
            return "e93ab38622f4e8270eae0d962204a90c";
        }
        VoteInfoMeta()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            term = 0;
            votedfor = "";
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (term != 0)
            {
                _os.write(term, 0);
            }
            if (votedfor != "")
            {
                _os.write(votedfor, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(term, 0, false);
            _is.read(votedfor, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(term,"term");
            _ds.display(votedfor,"votedfor");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(term, true);
            _ds.displaySimple(votedfor, false);
            return _os;
        }
    public:
        horsedb::Int64 term;
        std::string votedfor;
    };
    inline bool operator==(const VoteInfoMeta&l, const VoteInfoMeta&r)
    {
        return l.term == r.term && l.votedfor == r.votedfor;
    }
    inline bool operator!=(const VoteInfoMeta&l, const VoteInfoMeta&r)
    {
        return !(l == r);
    }

    struct ConfigurationMeta : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.ConfigurationMeta";
        }
        static string MD5()
        {
            return "8d34cd1c4b175e30a611ef7caf3f2480";
        }
        ConfigurationMeta()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (peers.size() > 0)
            {
                _os.write(peers, 0);
            }
            if (oldPeers.size() > 0)
            {
                _os.write(oldPeers, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(peers, 0, false);
            _is.read(oldPeers, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(peers,"peers");
            _ds.display(oldPeers,"oldPeers");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(peers, true);
            _ds.displaySimple(oldPeers, false);
            return _os;
        }
    public:
        vector<std::string> peers;
        vector<std::string> oldPeers;
    };
    inline bool operator==(const ConfigurationMeta&l, const ConfigurationMeta&r)
    {
        return l.peers == r.peers && l.oldPeers == r.oldPeers;
    }
    inline bool operator!=(const ConfigurationMeta&l, const ConfigurationMeta&r)
    {
        return !(l == r);
    }

    struct GetReq : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.GetReq";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        GetReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            skey = "";
            sDB = "";
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (skey != "")
            {
                _os.write(skey, 0);
            }
            if (sDB != "")
            {
                _os.write(sDB, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(skey, 0, false);
            _is.read(sDB, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(skey,"skey");
            _ds.display(sDB,"sDB");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(skey, true);
            _ds.displaySimple(sDB, false);
            return _os;
        }
    public:
        std::string skey;
        std::string sDB;
    };
    inline bool operator==(const GetReq&l, const GetReq&r)
    {
        return l.skey == r.skey && l.sDB == r.sDB;
    }
    inline bool operator!=(const GetReq&l, const GetReq&r)
    {
        return !(l == r);
    }

    struct GetRes : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.GetRes";
        }
        static string MD5()
        {
            return "86681cd5f50063b2f76c55e565a15975";
        }
        GetRes()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            skey = "";
            sValue = "";
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (skey != "")
            {
                _os.write(skey, 0);
            }
            if (sValue != "")
            {
                _os.write(sValue, 1);
            }
            _os.write((horsedb::Int32)status, 2);
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(skey, 0, false);
            _is.read(sValue, 1, false);
            horsedb::Int32 eTemp2 = horsedb::E_OK;
            _is.read(eTemp2, 2, false);
            status = (horsedb::EStatus)eTemp2;
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(skey,"skey");
            _ds.display(sValue,"sValue");
            _ds.display((horsedb::Int32)status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(skey, true);
            _ds.displaySimple(sValue, true);
            _ds.displaySimple((horsedb::Int32)status, false);
            return _os;
        }
    public:
        std::string skey;
        std::string sValue;
        horsedb::EStatus status;
    };
    inline bool operator==(const GetRes&l, const GetRes&r)
    {
        return l.skey == r.skey && l.sValue == r.sValue && l.status == r.status;
    }
    inline bool operator!=(const GetRes&l, const GetRes&r)
    {
        return !(l == r);
    }

    struct PutReq : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.PutReq";
        }
        static string MD5()
        {
            return "0c1d945735360d4e3752e1b2d448ba0c";
        }
        PutReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            sKey = "";
            sValue = "";
            sDB = "";
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (sKey != "")
            {
                _os.write(sKey, 0);
            }
            if (sValue != "")
            {
                _os.write(sValue, 1);
            }
            if (sDB != "")
            {
                _os.write(sDB, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sKey, 0, false);
            _is.read(sValue, 1, false);
            _is.read(sDB, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(sKey,"sKey");
            _ds.display(sValue,"sValue");
            _ds.display(sDB,"sDB");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sKey, true);
            _ds.displaySimple(sValue, true);
            _ds.displaySimple(sDB, false);
            return _os;
        }
    public:
        std::string sKey;
        std::string sValue;
        std::string sDB;
    };
    inline bool operator==(const PutReq&l, const PutReq&r)
    {
        return l.sKey == r.sKey && l.sValue == r.sValue && l.sDB == r.sDB;
    }
    inline bool operator!=(const PutReq&l, const PutReq&r)
    {
        return !(l == r);
    }

    struct PutRes : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.PutRes";
        }
        static string MD5()
        {
            return "570222e3ce2fda618f4b368c04d30636";
        }
        PutRes()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((horsedb::Int32)status, 0);
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            horsedb::Int32 eTemp0 = horsedb::E_OK;
            _is.read(eTemp0, 0, false);
            status = (horsedb::EStatus)eTemp0;
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display((horsedb::Int32)status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((horsedb::Int32)status, false);
            return _os;
        }
    public:
        horsedb::EStatus status;
    };
    inline bool operator==(const PutRes&l, const PutRes&r)
    {
        return l.status == r.status;
    }
    inline bool operator!=(const PutRes&l, const PutRes&r)
    {
        return !(l == r);
    }

    struct DelReq : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.DelReq";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        DelReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            sKey = "";
            sDB = "";
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (sKey != "")
            {
                _os.write(sKey, 0);
            }
            if (sDB != "")
            {
                _os.write(sDB, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sKey, 0, false);
            _is.read(sDB, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(sKey,"sKey");
            _ds.display(sDB,"sDB");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sKey, true);
            _ds.displaySimple(sDB, false);
            return _os;
        }
    public:
        std::string sKey;
        std::string sDB;
    };
    inline bool operator==(const DelReq&l, const DelReq&r)
    {
        return l.sKey == r.sKey && l.sDB == r.sDB;
    }
    inline bool operator!=(const DelReq&l, const DelReq&r)
    {
        return !(l == r);
    }

    struct DelRes : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.DelRes";
        }
        static string MD5()
        {
            return "570222e3ce2fda618f4b368c04d30636";
        }
        DelRes()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((horsedb::Int32)status, 0);
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            horsedb::Int32 eTemp0 = horsedb::E_OK;
            _is.read(eTemp0, 0, false);
            status = (horsedb::EStatus)eTemp0;
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display((horsedb::Int32)status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((horsedb::Int32)status, false);
            return _os;
        }
    public:
        horsedb::EStatus status;
    };
    inline bool operator==(const DelRes&l, const DelRes&r)
    {
        return l.status == r.status;
    }
    inline bool operator!=(const DelRes&l, const DelRes&r)
    {
        return !(l == r);
    }

    struct LogEntry : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.LogEntry";
        }
        static string MD5()
        {
            return "a971655827bbbb50d9c1b236da294a45";
        }
        LogEntry()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            term = 0;
            index = 0;
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((horsedb::Int32)cmdType, 0);
            _os.write(tGetReq, 1);
            _os.write(tPutReq, 2);
            _os.write(tDelReq, 3);
            if (term != 0)
            {
                _os.write(term, 4);
            }
            if (index != 0)
            {
                _os.write(index, 5);
            }
            if (vPeer.size() > 0)
            {
                _os.write(vPeer, 6);
            }
            if (vOldPeer.size() > 0)
            {
                _os.write(vOldPeer, 7);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            horsedb::Int32 eTemp0 = horsedb::CM_Noop;
            _is.read(eTemp0, 0, false);
            cmdType = (horsedb::CommandType)eTemp0;
            _is.read(tGetReq, 1, false);
            _is.read(tPutReq, 2, false);
            _is.read(tDelReq, 3, false);
            _is.read(term, 4, false);
            _is.read(index, 5, false);
            _is.read(vPeer, 6, false);
            _is.read(vOldPeer, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display((horsedb::Int32)cmdType,"cmdType");
            _ds.display(tGetReq,"tGetReq");
            _ds.display(tPutReq,"tPutReq");
            _ds.display(tDelReq,"tDelReq");
            _ds.display(term,"term");
            _ds.display(index,"index");
            _ds.display(vPeer,"vPeer");
            _ds.display(vOldPeer,"vOldPeer");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((horsedb::Int32)cmdType, true);
            _ds.displaySimple(tGetReq, true);
            _ds.displaySimple(tPutReq, true);
            _ds.displaySimple(tDelReq, true);
            _ds.displaySimple(term, true);
            _ds.displaySimple(index, true);
            _ds.displaySimple(vPeer, true);
            _ds.displaySimple(vOldPeer, false);
            return _os;
        }
    public:
        horsedb::CommandType cmdType;
        horsedb::GetReq tGetReq;
        horsedb::PutReq tPutReq;
        horsedb::DelReq tDelReq;
        horsedb::Int32 term;
        horsedb::Int32 index;
        vector<std::string> vPeer;
        vector<std::string> vOldPeer;
    };
    inline bool operator==(const LogEntry&l, const LogEntry&r)
    {
        return l.cmdType == r.cmdType && l.tGetReq == r.tGetReq && l.tPutReq == r.tPutReq && l.tDelReq == r.tDelReq && l.term == r.term && l.index == r.index && l.vPeer == r.vPeer && l.vOldPeer == r.vOldPeer;
    }
    inline bool operator!=(const LogEntry&l, const LogEntry&r)
    {
        return !(l == r);
    }

    struct AppendEntriesReq : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.AppendEntriesReq";
        }
        static string MD5()
        {
            return "d6092eb992ba8905547dcc940028d941";
        }
        AppendEntriesReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupID = "";
            peerID = "";
            serverID = "";
            prevLogIndex = 0;
            prevLogTerm = 0;
            term = 0;
            commitIndex = 0;
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (groupID != "")
            {
                _os.write(groupID, 0);
            }
            if (peerID != "")
            {
                _os.write(peerID, 1);
            }
            if (serverID != "")
            {
                _os.write(serverID, 2);
            }
            if (prevLogIndex != 0)
            {
                _os.write(prevLogIndex, 3);
            }
            if (prevLogTerm != 0)
            {
                _os.write(prevLogTerm, 4);
            }
            if (logEntries.size() > 0)
            {
                _os.write(logEntries, 5);
            }
            if (term != 0)
            {
                _os.write(term, 6);
            }
            if (commitIndex != 0)
            {
                _os.write(commitIndex, 7);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupID, 0, false);
            _is.read(peerID, 1, false);
            _is.read(serverID, 2, false);
            _is.read(prevLogIndex, 3, false);
            _is.read(prevLogTerm, 4, false);
            _is.read(logEntries, 5, false);
            _is.read(term, 6, false);
            _is.read(commitIndex, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(groupID,"groupID");
            _ds.display(peerID,"peerID");
            _ds.display(serverID,"serverID");
            _ds.display(prevLogIndex,"prevLogIndex");
            _ds.display(prevLogTerm,"prevLogTerm");
            _ds.display(logEntries,"logEntries");
            _ds.display(term,"term");
            _ds.display(commitIndex,"commitIndex");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupID, true);
            _ds.displaySimple(peerID, true);
            _ds.displaySimple(serverID, true);
            _ds.displaySimple(prevLogIndex, true);
            _ds.displaySimple(prevLogTerm, true);
            _ds.displaySimple(logEntries, true);
            _ds.displaySimple(term, true);
            _ds.displaySimple(commitIndex, false);
            return _os;
        }
    public:
        std::string groupID;
        std::string peerID;
        std::string serverID;
        horsedb::Int32 prevLogIndex;
        horsedb::Int32 prevLogTerm;
        vector<horsedb::LogEntry> logEntries;
        horsedb::Int32 term;
        horsedb::Int32 commitIndex;
    };
    inline bool operator==(const AppendEntriesReq&l, const AppendEntriesReq&r)
    {
        return l.groupID == r.groupID && l.peerID == r.peerID && l.serverID == r.serverID && l.prevLogIndex == r.prevLogIndex && l.prevLogTerm == r.prevLogTerm && l.logEntries == r.logEntries && l.term == r.term && l.commitIndex == r.commitIndex;
    }
    inline bool operator!=(const AppendEntriesReq&l, const AppendEntriesReq&r)
    {
        return !(l == r);
    }

    struct AppendEntriesRes : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.AppendEntriesRes";
        }
        static string MD5()
        {
            return "fa17c371fa7f6d162824593f25d47906";
        }
        AppendEntriesRes()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            term = 0;
            isSuccess = true;
            lastLogIndex = 0;
            isReadOnly = true;
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (term != 0)
            {
                _os.write(term, 0);
            }
            if (isSuccess != true)
            {
                _os.write(isSuccess, 1);
            }
            if (lastLogIndex != 0)
            {
                _os.write(lastLogIndex, 2);
            }
            if (isReadOnly != true)
            {
                _os.write(isReadOnly, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(term, 0, false);
            _is.read(isSuccess, 1, false);
            _is.read(lastLogIndex, 2, false);
            _is.read(isReadOnly, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(term,"term");
            _ds.display(isSuccess,"isSuccess");
            _ds.display(lastLogIndex,"lastLogIndex");
            _ds.display(isReadOnly,"isReadOnly");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(term, true);
            _ds.displaySimple(isSuccess, true);
            _ds.displaySimple(lastLogIndex, true);
            _ds.displaySimple(isReadOnly, false);
            return _os;
        }
    public:
        horsedb::Int32 term;
        horsedb::Bool isSuccess;
        horsedb::Int32 lastLogIndex;
        horsedb::Bool isReadOnly;
    };
    inline bool operator==(const AppendEntriesRes&l, const AppendEntriesRes&r)
    {
        return l.term == r.term && l.isSuccess == r.isSuccess && l.lastLogIndex == r.lastLogIndex && l.isReadOnly == r.isReadOnly;
    }
    inline bool operator!=(const AppendEntriesRes&l, const AppendEntriesRes&r)
    {
        return !(l == r);
    }

    struct RequestVoteReq : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.RequestVoteReq";
        }
        static string MD5()
        {
            return "0e75f62b433b70c9298e48d40d9b78ad";
        }
        RequestVoteReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupID = "";
            peerID = "";
            serverID = "";
            term = 0;
            lastLogIndex = 0;
            lastLogTerm = 0;
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (groupID != "")
            {
                _os.write(groupID, 0);
            }
            if (peerID != "")
            {
                _os.write(peerID, 1);
            }
            if (serverID != "")
            {
                _os.write(serverID, 2);
            }
            if (term != 0)
            {
                _os.write(term, 3);
            }
            if (lastLogIndex != 0)
            {
                _os.write(lastLogIndex, 4);
            }
            if (lastLogTerm != 0)
            {
                _os.write(lastLogTerm, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupID, 0, false);
            _is.read(peerID, 1, false);
            _is.read(serverID, 2, false);
            _is.read(term, 3, false);
            _is.read(lastLogIndex, 4, false);
            _is.read(lastLogTerm, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(groupID,"groupID");
            _ds.display(peerID,"peerID");
            _ds.display(serverID,"serverID");
            _ds.display(term,"term");
            _ds.display(lastLogIndex,"lastLogIndex");
            _ds.display(lastLogTerm,"lastLogTerm");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupID, true);
            _ds.displaySimple(peerID, true);
            _ds.displaySimple(serverID, true);
            _ds.displaySimple(term, true);
            _ds.displaySimple(lastLogIndex, true);
            _ds.displaySimple(lastLogTerm, false);
            return _os;
        }
    public:
        std::string groupID;
        std::string peerID;
        std::string serverID;
        horsedb::Int32 term;
        horsedb::Int32 lastLogIndex;
        horsedb::Int32 lastLogTerm;
    };
    inline bool operator==(const RequestVoteReq&l, const RequestVoteReq&r)
    {
        return l.groupID == r.groupID && l.peerID == r.peerID && l.serverID == r.serverID && l.term == r.term && l.lastLogIndex == r.lastLogIndex && l.lastLogTerm == r.lastLogTerm;
    }
    inline bool operator!=(const RequestVoteReq&l, const RequestVoteReq&r)
    {
        return !(l == r);
    }

    struct RequestVoteRes : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.RequestVoteRes";
        }
        static string MD5()
        {
            return "0cb6a73bdf64733620b1b764bbc73ecc";
        }
        RequestVoteRes()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            term = 0;
            isVoteGranted = true;
            peerID = "";
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (term != 0)
            {
                _os.write(term, 0);
            }
            if (isVoteGranted != true)
            {
                _os.write(isVoteGranted, 1);
            }
            if (peerID != "")
            {
                _os.write(peerID, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(term, 0, false);
            _is.read(isVoteGranted, 1, false);
            _is.read(peerID, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(term,"term");
            _ds.display(isVoteGranted,"isVoteGranted");
            _ds.display(peerID,"peerID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(term, true);
            _ds.displaySimple(isVoteGranted, true);
            _ds.displaySimple(peerID, false);
            return _os;
        }
    public:
        horsedb::Int32 term;
        horsedb::Bool isVoteGranted;
        std::string peerID;
    };
    inline bool operator==(const RequestVoteRes&l, const RequestVoteRes&r)
    {
        return l.term == r.term && l.isVoteGranted == r.isVoteGranted && l.peerID == r.peerID;
    }
    inline bool operator!=(const RequestVoteRes&l, const RequestVoteRes&r)
    {
        return !(l == r);
    }

    struct SnapshotMeta : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.SnapshotMeta";
        }
        static string MD5()
        {
            return "eaaa629dcc57b6e5649359489e0c621f";
        }
        SnapshotMeta()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            lastIncludedIndex = 0;
            lastIncludedTerm = 0;
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (lastIncludedIndex != 0)
            {
                _os.write(lastIncludedIndex, 0);
            }
            if (lastIncludedTerm != 0)
            {
                _os.write(lastIncludedTerm, 1);
            }
            if (peers.size() > 0)
            {
                _os.write(peers, 2);
            }
            if (oldPeers.size() > 0)
            {
                _os.write(oldPeers, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(lastIncludedIndex, 0, false);
            _is.read(lastIncludedTerm, 1, false);
            _is.read(peers, 2, false);
            _is.read(oldPeers, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(lastIncludedIndex,"lastIncludedIndex");
            _ds.display(lastIncludedTerm,"lastIncludedTerm");
            _ds.display(peers,"peers");
            _ds.display(oldPeers,"oldPeers");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(lastIncludedIndex, true);
            _ds.displaySimple(lastIncludedTerm, true);
            _ds.displaySimple(peers, true);
            _ds.displaySimple(oldPeers, false);
            return _os;
        }
    public:
        horsedb::Int32 lastIncludedIndex;
        horsedb::Int32 lastIncludedTerm;
        vector<std::string> peers;
        vector<std::string> oldPeers;
    };
    inline bool operator==(const SnapshotMeta&l, const SnapshotMeta&r)
    {
        return l.lastIncludedIndex == r.lastIncludedIndex && l.lastIncludedTerm == r.lastIncludedTerm && l.peers == r.peers && l.oldPeers == r.oldPeers;
    }
    inline bool operator!=(const SnapshotMeta&l, const SnapshotMeta&r)
    {
        return !(l == r);
    }

    struct InstallSnapshotReq : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.InstallSnapshotReq";
        }
        static string MD5()
        {
            return "6e1e557da03688de06c7c9242658f7c5";
        }
        InstallSnapshotReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupID = "";
            peerID = "";
            serverID = "";
            term = 0;
            uri = "";
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (groupID != "")
            {
                _os.write(groupID, 0);
            }
            if (peerID != "")
            {
                _os.write(peerID, 1);
            }
            if (serverID != "")
            {
                _os.write(serverID, 2);
            }
            if (term != 0)
            {
                _os.write(term, 3);
            }
            _os.write(meta, 4);
            if (uri != "")
            {
                _os.write(uri, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupID, 0, false);
            _is.read(peerID, 1, false);
            _is.read(serverID, 2, false);
            _is.read(term, 3, false);
            _is.read(meta, 4, false);
            _is.read(uri, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(groupID,"groupID");
            _ds.display(peerID,"peerID");
            _ds.display(serverID,"serverID");
            _ds.display(term,"term");
            _ds.display(meta,"meta");
            _ds.display(uri,"uri");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupID, true);
            _ds.displaySimple(peerID, true);
            _ds.displaySimple(serverID, true);
            _ds.displaySimple(term, true);
            _ds.displaySimple(meta, true);
            _ds.displaySimple(uri, false);
            return _os;
        }
    public:
        std::string groupID;
        std::string peerID;
        std::string serverID;
        horsedb::Int32 term;
        horsedb::SnapshotMeta meta;
        std::string uri;
    };
    inline bool operator==(const InstallSnapshotReq&l, const InstallSnapshotReq&r)
    {
        return l.groupID == r.groupID && l.peerID == r.peerID && l.serverID == r.serverID && l.term == r.term && l.meta == r.meta && l.uri == r.uri;
    }
    inline bool operator!=(const InstallSnapshotReq&l, const InstallSnapshotReq&r)
    {
        return !(l == r);
    }

    struct InstallSnapshotRes : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.InstallSnapshotRes";
        }
        static string MD5()
        {
            return "0cb6a73bdf64733620b1b764bbc73ecc";
        }
        InstallSnapshotRes()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            term = 0;
            isSuccess = true;
            peerID = "";
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (term != 0)
            {
                _os.write(term, 0);
            }
            if (isSuccess != true)
            {
                _os.write(isSuccess, 1);
            }
            if (peerID != "")
            {
                _os.write(peerID, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(term, 0, false);
            _is.read(isSuccess, 1, false);
            _is.read(peerID, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(term,"term");
            _ds.display(isSuccess,"isSuccess");
            _ds.display(peerID,"peerID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(term, true);
            _ds.displaySimple(isSuccess, true);
            _ds.displaySimple(peerID, false);
            return _os;
        }
    public:
        horsedb::Int32 term;
        horsedb::Bool isSuccess;
        std::string peerID;
    };
    inline bool operator==(const InstallSnapshotRes&l, const InstallSnapshotRes&r)
    {
        return l.term == r.term && l.isSuccess == r.isSuccess && l.peerID == r.peerID;
    }
    inline bool operator!=(const InstallSnapshotRes&l, const InstallSnapshotRes&r)
    {
        return !(l == r);
    }

    struct TimeoutNowReq : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.TimeoutNowReq";
        }
        static string MD5()
        {
            return "521b134839584223864dd6e99c930860";
        }
        TimeoutNowReq()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            groupID = "";
            peerID = "";
            serverID = "";
            term = 0;
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (groupID != "")
            {
                _os.write(groupID, 0);
            }
            if (peerID != "")
            {
                _os.write(peerID, 1);
            }
            if (serverID != "")
            {
                _os.write(serverID, 2);
            }
            if (term != 0)
            {
                _os.write(term, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupID, 0, false);
            _is.read(peerID, 1, false);
            _is.read(serverID, 2, false);
            _is.read(term, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(groupID,"groupID");
            _ds.display(peerID,"peerID");
            _ds.display(serverID,"serverID");
            _ds.display(term,"term");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupID, true);
            _ds.displaySimple(peerID, true);
            _ds.displaySimple(serverID, true);
            _ds.displaySimple(term, false);
            return _os;
        }
    public:
        std::string groupID;
        std::string peerID;
        std::string serverID;
        horsedb::Int32 term;
    };
    inline bool operator==(const TimeoutNowReq&l, const TimeoutNowReq&r)
    {
        return l.groupID == r.groupID && l.peerID == r.peerID && l.serverID == r.serverID && l.term == r.term;
    }
    inline bool operator!=(const TimeoutNowReq&l, const TimeoutNowReq&r)
    {
        return !(l == r);
    }

    struct TimeoutNowRes : public horsedb::TarsStructBase
    {
    public:
        static string className()
        {
            return "horsedb.TimeoutNowRes";
        }
        static string MD5()
        {
            return "0cb6a73bdf64733620b1b764bbc73ecc";
        }
        TimeoutNowRes()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            term = 0;
            isSuccess = true;
            peerID = "";
        }
        template<typename WriterT>
        void writeTo(horsedb::TarsOutputStream<WriterT>& _os) const
        {
            if (term != 0)
            {
                _os.write(term, 0);
            }
            if (isSuccess != true)
            {
                _os.write(isSuccess, 1);
            }
            if (peerID != "")
            {
                _os.write(peerID, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(horsedb::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(term, 0, false);
            _is.read(isSuccess, 1, false);
            _is.read(peerID, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.display(term,"term");
            _ds.display(isSuccess,"isSuccess");
            _ds.display(peerID,"peerID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            horsedb::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(term, true);
            _ds.displaySimple(isSuccess, true);
            _ds.displaySimple(peerID, false);
            return _os;
        }
    public:
        horsedb::Int32 term;
        horsedb::Bool isSuccess;
        std::string peerID;
    };
    inline bool operator==(const TimeoutNowRes&l, const TimeoutNowRes&r)
    {
        return l.term == r.term && l.isSuccess == r.isSuccess && l.peerID == r.peerID;
    }
    inline bool operator!=(const TimeoutNowRes&l, const TimeoutNowRes&r)
    {
        return !(l == r);
    }


    /* callback of async proxy for client */
    class RaftDBPrxCallback: public horsedb::ServantProxyCallback
    {
    public:
        virtual ~RaftDBPrxCallback(){}
        virtual void callback_appendEntries(horsedb::Int32 ret,  const horsedb::AppendEntriesRes& tRes)
        { throw std::runtime_error("callback_appendEntries() override incorrect."); }
        virtual void callback_appendEntries_exception(horsedb::Int32 ret)
        { throw std::runtime_error("callback_appendEntries_exception() override incorrect."); }

        virtual void callback_installSnapshot(horsedb::Int32 ret,  const horsedb::InstallSnapshotRes& tRes)
        { throw std::runtime_error("callback_installSnapshot() override incorrect."); }
        virtual void callback_installSnapshot_exception(horsedb::Int32 ret)
        { throw std::runtime_error("callback_installSnapshot_exception() override incorrect."); }

        virtual void callback_preVote(horsedb::Int32 ret,  const horsedb::RequestVoteRes& tRes)
        { throw std::runtime_error("callback_preVote() override incorrect."); }
        virtual void callback_preVote_exception(horsedb::Int32 ret)
        { throw std::runtime_error("callback_preVote_exception() override incorrect."); }

        virtual void callback_requestVote(horsedb::Int32 ret,  const horsedb::RequestVoteRes& tRes)
        { throw std::runtime_error("callback_requestVote() override incorrect."); }
        virtual void callback_requestVote_exception(horsedb::Int32 ret)
        { throw std::runtime_error("callback_requestVote_exception() override incorrect."); }

        virtual void callback_timeoutNow(horsedb::Int32 ret,  const horsedb::TimeoutNowRes& tRes)
        { throw std::runtime_error("callback_timeoutNow() override incorrect."); }
        virtual void callback_timeoutNow_exception(horsedb::Int32 ret)
        { throw std::runtime_error("callback_timeoutNow_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(horsedb::ReqMessagePtr msg)
        {
            static ::std::string __RaftDB_all[]=
            {
                "appendEntries",
                "installSnapshot",
                "preVote",
                "requestVote",
                "timeoutNow"
            };
            pair<string*, string*> r = equal_range(__RaftDB_all, __RaftDB_all+5, string(msg->request.sFuncName));
            if(r.first == r.second) return horsedb::TARSSERVERNOFUNCERR;
            switch(r.first - __RaftDB_all)
            {
                case 0:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_appendEntries_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    horsedb::Int32 _ret;
                    _is.read(_ret, 0, true);

                    horsedb::AppendEntriesRes tRes;
                    _is.read(tRes, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_appendEntries(_ret, tRes);

                    pCbtd->delResponseContext();

                    return horsedb::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_installSnapshot_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    horsedb::Int32 _ret;
                    _is.read(_ret, 0, true);

                    horsedb::InstallSnapshotRes tRes;
                    _is.read(tRes, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_installSnapshot(_ret, tRes);

                    pCbtd->delResponseContext();

                    return horsedb::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_preVote_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    horsedb::Int32 _ret;
                    _is.read(_ret, 0, true);

                    horsedb::RequestVoteRes tRes;
                    _is.read(tRes, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_preVote(_ret, tRes);

                    pCbtd->delResponseContext();

                    return horsedb::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_requestVote_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    horsedb::Int32 _ret;
                    _is.read(_ret, 0, true);

                    horsedb::RequestVoteRes tRes;
                    _is.read(tRes, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_requestVote(_ret, tRes);

                    pCbtd->delResponseContext();

                    return horsedb::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_timeoutNow_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    horsedb::Int32 _ret;
                    _is.read(_ret, 0, true);

                    horsedb::TimeoutNowRes tRes;
                    _is.read(tRes, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response->context);

                    callback_timeoutNow(_ret, tRes);

                    pCbtd->delResponseContext();

                    return horsedb::TARSSERVERSUCCESS;

                }
            }
            return horsedb::TARSSERVERNOFUNCERR;
        }

    };
    typedef std::shared_ptr<RaftDBPrxCallback> RaftDBPrxCallbackPtr;

    /* callback of coroutine async proxy for client */
    class RaftDBCoroPrxCallback: public RaftDBPrxCallback
    {
    public:
        virtual ~RaftDBCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(horsedb::ReqMessagePtr msg)
        {
            static ::std::string __RaftDB_all[]=
            {
                "appendEntries",
                "installSnapshot",
                "preVote",
                "requestVote",
                "timeoutNow"
            };

            pair<string*, string*> r = equal_range(__RaftDB_all, __RaftDB_all+5, string(msg->request.sFuncName));
            if(r.first == r.second) return horsedb::TARSSERVERNOFUNCERR;
            switch(r.first - __RaftDB_all)
            {
                case 0:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_appendEntries_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        horsedb::Int32 _ret;
                        _is.read(_ret, 0, true);

                        horsedb::AppendEntriesRes tRes;
                        _is.read(tRes, 2, true);
                        setResponseContext(msg->response->context);

                        callback_appendEntries(_ret, tRes);

                    }
                    catch(std::exception &ex)
                    {
                        callback_appendEntries_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_appendEntries_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }

                    return horsedb::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_installSnapshot_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        horsedb::Int32 _ret;
                        _is.read(_ret, 0, true);

                        horsedb::InstallSnapshotRes tRes;
                        _is.read(tRes, 2, true);
                        setResponseContext(msg->response->context);

                        callback_installSnapshot(_ret, tRes);

                    }
                    catch(std::exception &ex)
                    {
                        callback_installSnapshot_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_installSnapshot_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }

                    return horsedb::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_preVote_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        horsedb::Int32 _ret;
                        _is.read(_ret, 0, true);

                        horsedb::RequestVoteRes tRes;
                        _is.read(tRes, 2, true);
                        setResponseContext(msg->response->context);

                        callback_preVote(_ret, tRes);

                    }
                    catch(std::exception &ex)
                    {
                        callback_preVote_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_preVote_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }

                    return horsedb::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_requestVote_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        horsedb::Int32 _ret;
                        _is.read(_ret, 0, true);

                        horsedb::RequestVoteRes tRes;
                        _is.read(tRes, 2, true);
                        setResponseContext(msg->response->context);

                        callback_requestVote(_ret, tRes);

                    }
                    catch(std::exception &ex)
                    {
                        callback_requestVote_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_requestVote_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }

                    return horsedb::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response->iRet != horsedb::TARSSERVERSUCCESS)
                    {
                        callback_timeoutNow_exception(msg->response->iRet);

                        return msg->response->iRet;
                    }
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;

                    _is.setBuffer(msg->response->sBuffer);
                    try
                    {
                        horsedb::Int32 _ret;
                        _is.read(_ret, 0, true);

                        horsedb::TimeoutNowRes tRes;
                        _is.read(tRes, 2, true);
                        setResponseContext(msg->response->context);

                        callback_timeoutNow(_ret, tRes);

                    }
                    catch(std::exception &ex)
                    {
                        callback_timeoutNow_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_timeoutNow_exception(horsedb::TARSCLIENTDECODEERR);

                        return horsedb::TARSCLIENTDECODEERR;
                    }

                    return horsedb::TARSSERVERSUCCESS;

                }
            }
            return horsedb::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef std::shared_ptr<RaftDBCoroPrxCallback> RaftDBCoroPrxCallbackPtr;

    /* proxy for client */
    class RaftDBProxy : public horsedb::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        horsedb::Int32 appendEntries(const horsedb::AppendEntriesReq & tReq,horsedb::AppendEntriesRes &tRes,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            _os.write(tRes, 2);
            std::map<string, string> _mStatus;
            shared_ptr<horsedb::ResponsePacket> rep = tars_invoke(horsedb::TARSNORMAL,"appendEntries", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            horsedb::TarsInputStream<horsedb::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            horsedb::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tRes, 2, true);
            return _ret;
        }

        void async_appendEntries(RaftDBPrxCallbackPtr callback,const horsedb::AppendEntriesReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"appendEntries", _os, context, _mStatus, callback);
        }
        
        void coro_appendEntries(RaftDBCoroPrxCallbackPtr callback,const horsedb::AppendEntriesReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"appendEntries", _os, context, _mStatus, callback, true);
        }

        horsedb::Int32 installSnapshot(const horsedb::InstallSnapshotReq & tReq,horsedb::InstallSnapshotRes &tRes,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            _os.write(tRes, 2);
            std::map<string, string> _mStatus;
            shared_ptr<horsedb::ResponsePacket> rep = tars_invoke(horsedb::TARSNORMAL,"installSnapshot", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            horsedb::TarsInputStream<horsedb::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            horsedb::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tRes, 2, true);
            return _ret;
        }

        void async_installSnapshot(RaftDBPrxCallbackPtr callback,const horsedb::InstallSnapshotReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"installSnapshot", _os, context, _mStatus, callback);
        }
        
        void coro_installSnapshot(RaftDBCoroPrxCallbackPtr callback,const horsedb::InstallSnapshotReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"installSnapshot", _os, context, _mStatus, callback, true);
        }

        horsedb::Int32 preVote(const horsedb::RequestVoteReq & tReq,horsedb::RequestVoteRes &tRes,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            _os.write(tRes, 2);
            std::map<string, string> _mStatus;
            shared_ptr<horsedb::ResponsePacket> rep = tars_invoke(horsedb::TARSNORMAL,"preVote", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            horsedb::TarsInputStream<horsedb::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            horsedb::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tRes, 2, true);
            return _ret;
        }

        void async_preVote(RaftDBPrxCallbackPtr callback,const horsedb::RequestVoteReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"preVote", _os, context, _mStatus, callback);
        }
        
        void coro_preVote(RaftDBCoroPrxCallbackPtr callback,const horsedb::RequestVoteReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"preVote", _os, context, _mStatus, callback, true);
        }

        horsedb::Int32 requestVote(const horsedb::RequestVoteReq & tReq,horsedb::RequestVoteRes &tRes,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            _os.write(tRes, 2);
            std::map<string, string> _mStatus;
            shared_ptr<horsedb::ResponsePacket> rep = tars_invoke(horsedb::TARSNORMAL,"requestVote", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            horsedb::TarsInputStream<horsedb::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            horsedb::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tRes, 2, true);
            return _ret;
        }

        void async_requestVote(RaftDBPrxCallbackPtr callback,const horsedb::RequestVoteReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"requestVote", _os, context, _mStatus, callback);
        }
        
        void coro_requestVote(RaftDBCoroPrxCallbackPtr callback,const horsedb::RequestVoteReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"requestVote", _os, context, _mStatus, callback, true);
        }

        horsedb::Int32 timeoutNow(const horsedb::TimeoutNowReq & tReq,horsedb::TimeoutNowRes &tRes,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            _os.write(tRes, 2);
            std::map<string, string> _mStatus;
            shared_ptr<horsedb::ResponsePacket> rep = tars_invoke(horsedb::TARSNORMAL,"timeoutNow", _os, context, _mStatus);
            if(pResponseContext)
            {
                pResponseContext->swap(rep->context);
            }

            horsedb::TarsInputStream<horsedb::BufferReader> _is;
            _is.setBuffer(rep->sBuffer);
            horsedb::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tRes, 2, true);
            return _ret;
        }

        void async_timeoutNow(RaftDBPrxCallbackPtr callback,const horsedb::TimeoutNowReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"timeoutNow", _os, context, _mStatus, callback);
        }
        
        void coro_timeoutNow(RaftDBCoroPrxCallbackPtr callback,const horsedb::TimeoutNowReq &tReq,const map<string, string>& context = TARS_CONTEXT())
        {
            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
            _os.write(tReq, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(horsedb::TARSNORMAL,"timeoutNow", _os, context, _mStatus, callback, true);
        }

        RaftDBProxy* tars_hash(int64_t key)
        {
            return (RaftDBProxy*)ServantProxy::tars_hash(key);
        }

        RaftDBProxy* tars_consistent_hash(int64_t key)
        {
            return (RaftDBProxy*)ServantProxy::tars_consistent_hash(key);
        }

        RaftDBProxy* tars_set_timeout(int msecond)
        {
            return (RaftDBProxy*)ServantProxy::tars_set_timeout(msecond);
        }

        static const char* tars_prxname() { return "RaftDBProxy"; }
    };
    typedef std::shared_ptr<RaftDBProxy> RaftDBPrx;

    /* servant for server */
    class RaftDB :public horsedb::Servant
    {
    public:
        virtual ~RaftDB(){}
        virtual horsedb::Int32 appendEntries(const horsedb::AppendEntriesReq & tReq,horsedb::AppendEntriesRes &tRes,horsedb::TarsCurrentPtr current) ;
        static void async_response_appendEntries(horsedb::TarsCurrentPtr current, horsedb::Int32 _ret, const horsedb::AppendEntriesRes &tRes)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("tRes", tRes);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(horsedb::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tRes, 2);

                current->sendResponse(horsedb::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual horsedb::Int32 installSnapshot(const horsedb::InstallSnapshotReq & tReq,horsedb::InstallSnapshotRes &tRes,horsedb::TarsCurrentPtr current) ;
        static void async_response_installSnapshot(horsedb::TarsCurrentPtr current, horsedb::Int32 _ret, const horsedb::InstallSnapshotRes &tRes)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("tRes", tRes);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(horsedb::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tRes, 2);

                current->sendResponse(horsedb::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual horsedb::Int32 preVote(const horsedb::RequestVoteReq & tReq,horsedb::RequestVoteRes &tRes,horsedb::TarsCurrentPtr current) ;
        static void async_response_preVote(horsedb::TarsCurrentPtr current, horsedb::Int32 _ret, const horsedb::RequestVoteRes &tRes)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("tRes", tRes);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(horsedb::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tRes, 2);

                current->sendResponse(horsedb::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual horsedb::Int32 requestVote(const horsedb::RequestVoteReq & tReq,horsedb::RequestVoteRes &tRes,horsedb::TarsCurrentPtr current) ;
        static void async_response_requestVote(horsedb::TarsCurrentPtr current, horsedb::Int32 _ret, const horsedb::RequestVoteRes &tRes)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("tRes", tRes);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(horsedb::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tRes, 2);

                current->sendResponse(horsedb::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual horsedb::Int32 timeoutNow(const horsedb::TimeoutNowReq & tReq,horsedb::TimeoutNowRes &tRes,horsedb::TarsCurrentPtr current) ;
        static void async_response_timeoutNow(horsedb::TarsCurrentPtr current, horsedb::Int32 _ret, const horsedb::TimeoutNowRes &tRes)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tars_ret", _ret);
                tarsAttr.put("tRes", tRes);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(horsedb::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                _os.write(_ret, 0);

                _os.write(tRes, 2);

                current->sendResponse(horsedb::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(horsedb::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __horsedb__RaftDB_all[]=
            {
                "appendEntries",
                "installSnapshot",
                "preVote",
                "requestVote",
                "timeoutNow"
            };

            pair<string*, string*> r = equal_range(__horsedb__RaftDB_all, __horsedb__RaftDB_all+5, _current->getFuncName());
            if(r.first == r.second) return horsedb::TARSSERVERNOFUNCERR;
            switch(r.first - __horsedb__RaftDB_all)
            {
                case 0:
                {
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    horsedb::AppendEntriesReq tReq;
                    horsedb::AppendEntriesRes tRes;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("tReq", tReq);
                        tarsAttr.getByDefault("tRes", tRes, tRes);
                    }
                    else
                    {
                        _is.read(tReq, 1, true);
                        _is.read(tRes, 2, false);
                    }
                    horsedb::Int32 _ret = appendEntries(tReq,tRes, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("tRes", tRes);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tRes, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return horsedb::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    horsedb::InstallSnapshotReq tReq;
                    horsedb::InstallSnapshotRes tRes;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("tReq", tReq);
                        tarsAttr.getByDefault("tRes", tRes, tRes);
                    }
                    else
                    {
                        _is.read(tReq, 1, true);
                        _is.read(tRes, 2, false);
                    }
                    horsedb::Int32 _ret = installSnapshot(tReq,tRes, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("tRes", tRes);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tRes, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return horsedb::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    horsedb::RequestVoteReq tReq;
                    horsedb::RequestVoteRes tRes;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("tReq", tReq);
                        tarsAttr.getByDefault("tRes", tRes, tRes);
                    }
                    else
                    {
                        _is.read(tReq, 1, true);
                        _is.read(tRes, 2, false);
                    }
                    horsedb::Int32 _ret = preVote(tReq,tRes, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("tRes", tRes);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tRes, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return horsedb::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    horsedb::RequestVoteReq tReq;
                    horsedb::RequestVoteRes tRes;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("tReq", tReq);
                        tarsAttr.getByDefault("tRes", tRes, tRes);
                    }
                    else
                    {
                        _is.read(tReq, 1, true);
                        _is.read(tRes, 2, false);
                    }
                    horsedb::Int32 _ret = requestVote(tReq,tRes, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("tRes", tRes);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tRes, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return horsedb::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    horsedb::TarsInputStream<horsedb::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    horsedb::TimeoutNowReq tReq;
                    horsedb::TimeoutNowRes tRes;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("tReq", tReq);
                        tarsAttr.getByDefault("tRes", tRes, tRes);
                    }
                    else
                    {
                        _is.read(tReq, 1, true);
                        _is.read(tRes, 2, false);
                    }
                    horsedb::Int32 _ret = timeoutNow(tReq,tRes, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION)
                        {
                            UniAttribute<horsedb::BufferWriterVector, horsedb::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tars_ret", _ret);
                            tarsAttr.put("tRes", tRes);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            horsedb::TarsOutputStream<horsedb::BufferWriterVector> _os;
                            _os.write(_ret, 0);
                            _os.write(tRes, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return horsedb::TARSSERVERSUCCESS;

                }
            }
            return horsedb::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
